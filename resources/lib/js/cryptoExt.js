(()=>{"use strict";var e={982:e=>{e.exports=require("crypto")}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var l=t[n]={exports:{}};return e[n](l,l.exports,r),l.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};r.r(n),r.d(n,{CMAC:()=>p});var o=r(982),l=r.n(o);const u=Buffer.from("00000000000000000000000000000000","hex"),f=Buffer.from("00000000000000000000000000000087","hex"),c=16;function s(e){const t=Buffer.alloc(e.length),r=e.length-1;for(let n=0;n<r;n++)t[n]=e[n]<<1,128&e[n+1]&&(t[n]+=1);return t[r]=e[r]<<1,t}function a(e,t){const r=Math.min(e.length,t.length),n=Buffer.alloc(r);for(let o=0;o<r;o++)n[o]=e[o]^t[o];return n}function i(e,t){const r={16:"aes-128-cbc",24:"aes-192-cbc",32:"aes-256-cbc"};if(!r[e.length])throw new Error("Keys must be 128, 192, or 256 bits in length.");const n=l().createCipheriv(r[e.length],e,u),o=n.update(t);return n.final(),o}function p(e,t){const r=function(e){const t=i(e,u);let r=s(t);128&t[0]&&(r=a(r,f));let n=s(r);return 128&r[0]&&(n=a(n,f)),{subkey1:r,subkey2:n}}(e);let n,o,l,p=Math.ceil(t.length/c);0===p?(p=1,n=!1):n=t.length%c===0,l=p-1,o=n?a(b(t,l),r.subkey1):a(function(e,t){const r=Buffer.alloc(c),n=t*c,o=e.length;return r.fill(0),e.copy(r,0,n,o),r[o-n]=128,r}(t,l),r.subkey2);let h,y=Buffer.from("00000000000000000000000000000000","hex");for(let r=0;r<l;r++)h=a(y,b(t,r)),y=i(e,h);return h=a(o,y),i(e,h)}function b(e,t){const r=Buffer.alloc(c),n=t*c,o=n+c;return e.copy(r,0,n,o),r}var h=exports;for(var y in n)h[y]=n[y];n.__esModule&&Object.defineProperty(h,"__esModule",{value:!0})})();
//# sourceMappingURL=cryptoExt.js.map