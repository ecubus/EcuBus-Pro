import { dot } from 'node:test/reporters';
export { default as assert } from 'node:assert';

/**
 * Represents a CAN (Controller Area Network) message.
 *
 * @category CAN
 */
interface CanMessage {
    /**
     * The name of the CAN message.
     */
    name?: string;
    /**
     * The device associated with the CAN message.
     */
    device?: string;
    /**
     * The direction of the CAN message, either 'IN' for incoming or 'OUT' for outgoing.
     */
    dir: 'IN' | 'OUT';
    /**
     * The data payload of the CAN message.
     */
    data: Buffer;
    /**
     * The timestamp of when the CAN message was sent/recv.
     */
    ts?: number;
    /**
     * The identifier of the CAN message.
     */
    id: number;
    /**
     * The type of the CAN message.
     */
    msgType: CanMsgType;
    /**
     * Indicates whether the CAN message is simulated.
     * This property is optional.
     */
    isSimulate?: boolean;
    /**
     * The database name of the CAN message.
     */
    database?: string;
    /**
     * The children signals of the CAN message.
     * internal use
     */
    children?: {
        name: string;
        data: string;
    }[];
}
/**
 * Enumeration representing different CAN (Controller Area Network) ID types.
 *
 * @category CAN
 * @enum {string}
 * @readonly
 */
declare enum CAN_ID_TYPE {
    STANDARD = "STANDARD",
    EXTENDED = "EXTENDED"
}
/**
 * Enumeration representing different CAN (Controller Area Network) address types.
 *
 * @category CAN
 * @enum {string}
 * @readonly
 */
declare enum CAN_ADDR_TYPE {
    PHYSICAL = "PHYSICAL",
    FUNCTIONAL = "FUNCTIONAL"
}
/**
 * Enumeration representing different CAN (Controller Area Network) address formats.
 *
 * @category CAN
 * @enum {string}
 * @readonly
 */
declare enum CAN_ADDR_FORMAT {
    NORMAL = "NORMAL",
    FIXED_NORMAL = "NORMAL_FIXED",
    EXTENDED = "EXTENDED",
    MIXED = "MIXED",
    ENHANCED = "ENHANCED"
}
/**
 * Represents a CAN (Controller Area Network) message type.
 * @category CAN

 */
interface CanMsgType {
    /**
     * The type of CAN ID.
     */
    idType: CAN_ID_TYPE;
    /**
     * Indicates if Bit Rate Switching (BRS) is enabled.
     */
    brs: boolean;
    /**
     * Indicates if CAN FD (Flexible Data-rate) is used.
     */
    canfd: boolean;
    /**
     * Indicates if the message is a remote frame.
     */
    remote: boolean;
    /**
     * Optional unique identifier for the message.
     */
    uuid?: string;
}
/**
 * @category CAN
 */
interface CanAddr extends CanMsgType {
    name: string;
    addrFormat: CAN_ADDR_FORMAT;
    addrType: CAN_ADDR_TYPE;
    desc?: string;
    SA: string;
    TA: string;
    AE: string;
    canIdTx: string;
    canIdRx: string;
    nAs: number;
    nAr: number;
    nBs: number;
    nCr: number;
    nBr?: number;
    nCs?: number;
    stMin: number;
    bs: number;
    maxWTF: number;
    uuid?: string;
    dlc: number;
    padding: boolean;
    paddingValue: string;
}

/**
 * @category DOIP
 */
interface EthAddr {
    name: string;
    entity: EntityAddr;
    tester: TesterAddr;
    virReqType: 'unicast' | 'omit' | 'broadcast' | 'multicast';
    virReqAddr: string;
    entityNotFoundBehavior?: 'no' | 'normal' | 'withVin' | 'withEid' | 'forceNormal' | 'forceWithVin' | 'forceWithEid';
    taType: 'physical' | 'functional';
    udpClientPort?: number;
    tcpClientPort?: number;
}
interface TesterAddr {
    routeActiveTime: number;
    createConnectDelay: number;
    testerLogicalAddr: number;
}
interface VinInfo {
    vin: string;
    logicalAddr: number;
    eid: string;
    gid: string;
}
/**
 * @category DOIP
 */
interface EntityAddr extends VinInfo {
    nodeType?: 'node' | 'gateway';
    nodeAddr?: number;
    ta?: string;
    ip?: string;
    mcts?: number;
    ncts?: number;
    mds?: number;
    powerMode?: number;
    localPort?: number;
    sendSync?: boolean;
    udpLocalPort?: number;
    furtherAction?: number;
    syncStatus?: number;
}

/**
 * @category LIN
 */
declare enum LinDirection {
    SEND = "SEND",
    RECV = "RECV",
    RECV_AUTO_LEN = "RECV_AUTO_LEN"
}
/**
 * @category LIN
 */
declare enum LinMode {
    MASTER = "MASTER",
    SLAVE = "SLAVE"
}
/**
 * @category LIN
 */
declare enum LinChecksumType {
    CLASSIC = "CLASSIC",
    ENHANCED = "ENHANCED"
}
/**
 * LinCable Error Inject Control. See {@link https://app.whyengineer.com/docs/um/hardware/lincable.html} for details.
 * @category LIN
 */
interface LinCableErrorInject {
    /**
     * Break field length in bits
     * @default 13
     * @minimum 13
     * @maximum 26
     */
    breakLength?: number;
    /**
     * Break delimiter length in bits
     * @default 1
     * @minimum 0
     * @maximum 14.6
     */
    breakDelLength?: number;
    /**
     * Inter-byte space between sync byte field and identifier in bits
     * @default 0
     * @minimum 0
     * @maximum 14
     */
    hInterLength?: number;
    /**
     * Inter-byte spaces between data fields in bits. Array length must match data length.
     * @default 0
     * @minimum 0
     * @maximum 4
     */
    dInterLength?: number[];
    /**
     * Custom sync byte value. Set to false to prevent master from sending sync.
     * @default 0x55
     */
    syncVal?: number | false;
    /**
     * Custom PID value. Set to false to prevent master from sending PID.
     * @default getPID(frameId)
     */
    pid?: number | false;
    /**
     * Fault injection configuration
     */
    errorInject?: {
        /** Bit position to inject fault, starting from first break bit */
        bit: number;
        /** Fault value: 1 for high, 0 for low */
        value: 1 | 0;
    };
    /**
     * Override the checksum value
     */
    checkSum?: number;
}
/**
 * @category LIN
 */
interface LinMsg {
    frameId: number;
    data: Buffer;
    direction: LinDirection;
    checksumType: LinChecksumType;
    checksum?: number;
    database?: string;
    device?: string;
    workNode?: string;
    name?: string;
    isEvent?: boolean;
    uuid?: string;
    ts?: number;
    /**
     * The children signals of the CAN message.
     * internal use
     */
    children?: {
        name: string;
        data: string;
    }[];
    lincable?: LinCableErrorInject;
}
declare enum LIN_ADDR_TYPE {
    PHYSICAL = "PHYSICAL",
    FUNCTIONAL = "FUNCTIONAL"
}
declare enum LIN_SCH_TYPE {
    DIAG_ONLY = "DIAG_ONLY",
    DIAG_INTERLEAVED = "DIAG_INTERLEAVED"
}
/**
 * @category LIN
 */
interface LinAddr {
    name: string;
    addrType: LIN_ADDR_TYPE;
    nad: number;
    stMin: number;
    nAs: number;
    nCr: number;
    schType: LIN_SCH_TYPE;
}
/**
 * Calculate LIN frame checksum
 * @category LIN
 * @param data - Data bytes to calculate checksum for
 * @param checksumType - Type of checksum (CLASSIC for LIN 1.x or ENHANCED for LIN 2.x)
 * @param pid - Protected ID, required for enhanced checksum calculation
 * @returns Calculated checksum byte
 */
declare function getCheckSum(data: Buffer, checksumType: LinChecksumType, pid?: number): number;

/**
 * vSomeIP Configuration Interfaces
 *
 * This module contains comprehensive TypeScript interfaces for vSomeIP 3.5.5 configuration.
 * The main interface is split into multiple sub-interfaces for better organization and maintainability.
 *
 * @see {@link https://github.com/GENIVI/vsomeip/wiki/vsomeip-in-10-minutes#configuration}
 */

declare enum SomeipMessageType {
    REQUEST = 0,
    REQUEST_NO_RETURN = 1,
    NOTIFICATION = 2,
    RESPONSE = 128,
    REQUEST_ACK = 64,
    NOTIFICATION_ACK = 66,
    ERROR = 129,
    RESPONSE_ACK = 192,
    ERROR_ACK = 193,
    UNKNOWN = 255
}
interface SomeipMessage {
    uuid?: string;
    service: number;
    instance: number;
    method: number;
    client: number;
    session: number;
    payload: Buffer;
    messageType: SomeipMessageType;
    returnCode: number;
    protocolVersion: number;
    interfaceVersion: number;
    ts: number;
    reliable?: boolean;
    sending: boolean;
    protocol?: string;
    ip?: string;
    port?: number;
    database?: string;
    device?: string;
}

type DataType = 'NUM' | 'ARRAY' | 'ASCII' | 'UNICODE' | 'FLOAT' | 'DOUBLE' | 'FILE';
type HardwareType = 'can' | 'lin' | 'eth' | 'pwm' | 'someip';
/**
 * @category UDS
 */
interface ServiceItem {
    id: string;
    name: string;
    serviceId: ServiceId;
    subfunc?: string;
    suppress?: boolean;
    autoSubfunc?: boolean;
    desc?: string;
    params: Param[];
    respParams: Param[];
    isNegativeResponse?: boolean;
    nrc?: number;
    generateConfigs?: Record<string, string>;
}
interface Param {
    id: string;
    name: string;
    longName?: string;
    desc?: string;
    type: DataType;
    value: Buffer;
    phyValue: any;
    bitLen: number;
    bitPos?: number;
    meta?: {
        type: string;
    };
    deletable?: boolean;
    editable?: boolean;
}
/**
 * @category UDS
 */
type ServiceId = '0x10' | '0x11' | '0x27' | '0x28' | '0x29' | '0x3E' | '0x83' | '0x84' | '0x85' | '0x22' | '0x23' | '0x24' | '0x2A' | '0x2C' | '0x2E' | '0x3D' | '0x14' | '0x87' | '0x19' | '0x2F' | '0x31' | '0x34' | '0x35' | '0x36' | '0x37' | '0x38' | 'Job';
interface SequenceItem {
    uuid: string;
    enable: boolean;
    checkResp: boolean;
    retryNum: number;
    addressIndex: number;
    failBehavior: 'stop' | 'continue';
    serviceId: string;
    delay: number;
}
interface Sequence {
    name: string;
    services: SequenceItem[];
}
interface UdsInfo {
    pTime: number;
    pExtTime: number;
    s3Time: number;
    testerPresentEnable: boolean;
    testerPresentSpecialService?: string;
    testerPresentAddrIndex?: number;
}
/**
 * @category UDS
 */
interface UdsAddress {
    type: HardwareType;
    canAddr?: CanAddr;
    ethAddr?: EthAddr;
    linAddr?: LinAddr;
}

/**
 * @category UDS
 */
interface TesterInfo {
    script?: string;
    id: string;
    name: string;
    type: HardwareType;
    udsTime: UdsInfo;
    targetDeviceId?: string;
    seqList: Sequence[];
    address: UdsAddress[];
    simulateBy?: string;
    allServiceList: Partial<Record<ServiceId, ServiceItem[]>>;
    doipVersion?: number;
    enableCodeGen?: boolean;
    generateConfigs?: {
        tempaltePath: string;
        generatePath: string;
    }[];
}

/**
 * SOME/IP Worker Module
 *
 * This module provides SOME/IP (Scalable service-Oriented MiddlewarE over IP) message handling classes.
 * SOME/IP is an automotive communication protocol used for service-oriented communication in vehicles.
 *
 * Catalog: SOME/IP - Handles SOME/IP protocol message types and operations
 */

/**
 * @catalog SOME/IP
 * Base class for SOME/IP messages
 * This class provides the foundation for all SOME/IP message types.
 * It encapsulates the basic SOME/IP message structure and common functionality.
 */
declare class SomeipMessageBase {
    msg: SomeipMessage;
    /**
     * Creates a new SOME/IP message base instance
     * @param msg - The SOME/IP message data
     */
    constructor(msg: SomeipMessage);
    setPayload(payload: Buffer): void;
}
/**
 * SOME/IP Request Message Handler
 *
 * @catalog SOME/IP
 * This class handles SOME/IP request messages specifically.
 * It validates that the message type is REQUEST and provides request-specific functionality.
 */
declare class SomeipMessageRequest extends SomeipMessageBase {
    msg: SomeipMessage;
    /**
     * Creates a new SOME/IP request message instance
     * @param msg - The SOME/IP message data (must be of type REQUEST)
     * @throws {Error} If the message type is not REQUEST
     */
    constructor(msg: SomeipMessage);
}
/**
 * SOME/IP Response Message Handler
 * @catalog SOME/IP
 * This class handles SOME/IP response messages specifically.
 * It validates that the message type is RESPONSE and provides response-specific functionality,
 * including the ability to create responses from requests.
 */
declare class SomeipMessageResponse extends SomeipMessageBase {
    msg: SomeipMessage;
    /**
     * Creates a new SOME/IP response message instance
     * @param msg - The SOME/IP message data (must be of type RESPONSE)
     * @throws {Error} If the message type is not RESPONSE
     */
    constructor(msg: SomeipMessage);
    /**
     * Creates a SOME/IP response message from a request message
     *
     * This static method takes a request message and creates a corresponding response message
     * by copying the request data and changing the message type to RESPONSE.
     *
     * @param request - The SOME/IP request message to create a response from
     * @returns A new SomeipMessageResponse instance based on the request
     */
    static fromSomeipRequest(request: SomeipMessageRequest, payload?: Buffer): SomeipMessageResponse;
}

declare function registerWorker(methods: Record<string, Function>): void;
declare function workerEmit(payload: any): void;

/**
 * Test function for writing test cases with conditional execution based on enable control.
 * Provides test context, automatic logging, and supports both synchronous and asynchronous operations.
 * Test execution is controlled by the testEnableControl configuration.
 *
 * @category TEST
 * @param {string} name - The name of the test case
 * @param {Function} fn - The test function to execute (can be sync or async)
 * @property {Function} skip - Skip a test case, marking it as pending. The test will be reported as skipped and not executed.
 *
 * @example
 * ```ts
 * // Basic synchronous test case
 * test('should validate CAN message format', () => {
 *   const canMsg = { id: 0x123, data: [0x01, 0x02] };
 *   assert.equal(canMsg.id, 0x123);
 *   assert.equal(canMsg.data.length, 2);
 * });
 *
 * // Asynchronous test case for UDS communication
 * test('should perform UDS diagnostic session', async () => {
 *   await uds.service(0x10, 0x01); // DiagnosticSessionControl
 *   const response = await uds.getResponse();
 *   assert.equal(response[0], 0x50); // Positive response
 * });
 *
 * // Test with CAN bus operations
 * test('should send and receive CAN messages', async () => {
 *   await can.send({ id: 0x7E0, data: [0x02, 0x10, 0x01] });
 *   const msg = await can.recv(1000);
 *   assert.notEqual(msg, null);
 * });
 *
 * // Skip a test case when feature is not ready
 * test.skip('LIN transport protocol test', () => {
 *   // Test code that will be skipped
 *   lin.sendMessage(0x3C, [0x01, 0x02, 0x03]);
 * });
 * ```
 */
declare function test(name: string, fn: () => void | Promise<void>): void;
declare namespace test {
    var skip: (name: string, fn: () => void | Promise<void>) => void;
}
/**
 * Run setup code before each test in the current suite.
 * **MUST be used within a describe block.** Only executes if the corresponding test is enabled through testEnableControl.
 * Useful for initializing test data, establishing connections, or setting up mock objects.
 *
 * @category TEST
 * @param {Function} fn - Function to run before each test (can be sync or async)
 *
 * @example
 * ```ts
 * describe('CAN Communication Tests', () => {
 *   // ✅ Correct: beforeEach inside describe block
 *   beforeEach(async () => {
 *     await can.open('kvaser', 0);
 *     await can.setBitrate(500000);
 *   });
 *
 *   beforeEach(() => {
 *     uds.setTesterPresent(true);
 *     uds.setTimeout(5000);
 *   });
 *
 *   test('should send CAN message', () => {
 *     // Test implementation
 *   });
 * });
 *
 * // ❌ Wrong: beforeEach outside describe block
 * // beforeEach(() => { // This will not work properly });
 * ```
 */
declare function beforeEach(fn: () => void | Promise<void>): void;
/**
 * Run cleanup code after each test in the current suite.
 * **MUST be used within a describe block.** Only executes if the corresponding test is enabled through testEnableControl.
 * Used for cleaning up resources, closing connections, or resetting state after each test.
 *
 * @category TEST
 * @param {Function} fn - Function to run after each test (can be sync or async)
 *
 * @example
 * ```ts
 * describe('UDS Diagnostic Tests', () => {
 *   // ✅ Correct: afterEach inside describe block
 *   afterEach(async () => {
 *     await can.close();
 *   });
 *
 *   afterEach(() => {
 *     uds.setTesterPresent(false);
 *     uds.clearDtc();
 *     testData = null;
 *   });
 *
 *   test('should perform diagnostics', () => {
 *     // Test implementation
 *   });
 * });
 *
 * // ❌ Wrong: afterEach outside describe block
 * // afterEach(() => { // This will not work properly });
 * ```
 */
declare function afterEach(fn: () => void | Promise<void>): void;
/**
 * Run setup code before all tests in the current suite.
 * **MUST be used within a describe block.** Only executes if any test in the suite is enabled through testEnableControl.
 * Used for one-time setup operations like initializing hardware, loading configuration, or establishing database connections.
 *
 * @category TEST
 * @param {Function} fn - Function to run before all tests (can be sync or async)
 *
 * @example
 * ```ts
 * describe('Hardware Integration Tests', () => {
 *   // ✅ Correct: before inside describe block
 *   before(async () => {
 *     await hardware.initialize();
 *     await hardware.selfTest();
 *   });
 *
 *   before(() => {
 *     config = loadTestConfig('test-settings.json');
 *     process.env.TEST_MODE = 'true';
 *   });
 *
 *   test('should connect to ECU', () => {
 *     // Test implementation
 *   });
 * });
 *
 * // ❌ Wrong: before outside describe block
 * // before(() => { // This will not work properly });
 * ```
 */
declare function before(fn: () => void | Promise<void>): void;
/**
 * Run cleanup code after all tests in the current suite.
 * **MUST be used within a describe block.** Only executes if any test in the suite was enabled through testEnableControl.
 * Used for final cleanup operations like closing hardware connections, saving test reports, or cleaning up temporary files.
 *
 * @category TEST
 * @param {Function} fn - Function to run after all tests (can be sync or async)
 *
 * @example
 * ```ts
 * describe('System Integration Tests', () => {
 *   // ✅ Correct: after inside describe block
 *   after(async () => {
 *     await hardware.shutdown();
 *     await hardware.disconnect();
 *   });
 *
 *   after(() => {
 *     saveTestReport(testResults);
 *     delete process.env.TEST_MODE;
 *     console.log('All tests completed');
 *   });
 *
 *   test('should perform system check', () => {
 *     // Test implementation
 *   });
 * });
 *
 * // ❌ Wrong: after outside describe block
 * // after(() => { // This will not work properly });
 * ```
 */
declare function after(fn: () => void | Promise<void>): void;

/**
 * Create a test group to organize related test cases.
 * **Required container for all test hook functions** (before, after, beforeEach, afterEach).
 * Groups tests logically and provides a scope for shared setup/teardown operations.
 * Automatically increments test counter for proper test enable control tracking.
 *
 * @category TEST
 * @param {string} name - Test group name that describes the functionality being tested
 * @param {Function} fn - Test group function containing test cases and hooks
 *
 * @example
 * ```ts
 * // ✅ Correct: All hooks must be inside describe blocks
 * describe('CAN Communication Tests', () => {
 *   before(async () => {
 *     // One-time setup for the entire test suite
 *     await hardware.initialize();
 *   });
 *
 *   beforeEach(async () => {
 *     // Setup before each test
 *     await can.open('kvaser', 0);
 *   });
 *
 *   test('should send CAN message', () => {
 *     const result = can.send({ id: 0x123, data: [0x01, 0x02] });
 *     assert.equal(result, true);
 *   });
 *
 *   test('should receive CAN message', async () => {
 *     const msg = await can.recv(1000);
 *     assert.notEqual(msg, null);
 *   });
 *
 *   afterEach(async () => {
 *     // Cleanup after each test
 *     await can.close();
 *   });
 *
 *   after(() => {
 *     // Final cleanup for the entire test suite
 *     console.log('All CAN tests completed');
 *   });
 * });
 *
 * // ❌ Wrong: Hooks outside describe blocks will not work
 * // before(() => { // This is invalid });
 * // beforeEach(() => { // This is invalid });
 * // test('standalone test', () => { // This works but hooks don't apply });
 * ```
 */
declare function describe(name: string, fn: () => void | Promise<void>): void;
declare const testerList: readonly [
                {{#each this.testers}}
                    "{{this}}",
                {{/each}}
            ];
declare const serviceList: readonly [
    {{#each this.services}}
        "{{this}}",
    {{/each}}
];
declare const allServicesSend: readonly [
    {{#each this.services}}
        "{{this}}.send",
    {{/each}}
];
declare const allServicesRecv: readonly [
    {{#each this.services}}
        "{{this}}.recv",
    {{/each}}
];
declare const allSignal: readonly [
    {{#each this.signals}}
        "{{this}}",
    {{/each}}
];
declare const allUdsSeq: readonly [
    {{#each this.udsSeqName}}
        "{{this}}",
    {{/each}}
];
interface Jobs {
{{#each this.jobs}}
    "{{this.name}}": ({{#each this.param}}{{this}},{{/each}}) => DiagRequest[]|Promise<DiagRequest[]>;
{{/each}}
}
/**
 * All services name config in Diagnostic Service.
 * @category UDS
 */
type ServiceName = (typeof serviceList)[number];
/**
 * All testers name config in Diagnostic Service.
 * @category UDS
 */
type TesterName = (typeof testerList)[number];
/**
 * All services name(.send) config in Diagnostic Service.
 * @category UDS
 */
type ServiceNameSend = (typeof allServicesSend)[number];
/**
 * All services name(.recv) config in Diagnostic Service.
 * @category UDS
 */
type ServiceNameRecv = (typeof allServicesRecv)[number];
/**
 * All UDS sequence names configured in Diagnostic Service.
 * @category UDS
 */
type UdsSeqName = (typeof allUdsSeq)[number];
/**
 * All signals name config in Diagnostic Service.
 * @category LIN
 * @category CAN
 */
type SignalName = (typeof allSignal)[number];
/**
 * All variables name config in Diagnostic Service.
 * @category UDS
 */
type VariableMap = {
    "*":number|string|number[],
    {{#each this.variables}}
        "{{this.name}}":{{this.type}},
    {{/each}}
};
/**
 * All jobs name config in Diagnostic Service.
 * @category UDS
 */
type JobName = keyof Jobs;
type EventMapSend = {
    [key in ServiceNameSend]: DiagRequest;
};
type EventMapRecv = {
    [key in ServiceNameRecv]: DiagResponse;
};
type EventMap = EventMapSend & EventMapRecv;
/**
 * @category UDS
 */
type ServiceEvent = {
    send: DiagRequest;
    recv: DiagResponse;
};
/**
 * @category UDS
 */
declare class Service {
    
    private params;
    private isRequest;
    testerName: string;
    constructor(testerName: string, service: ServiceItem, isRequest: boolean);
    valueOf(): string;
    /**
     * Sync service params to tester sequence, after change, the sequence params will be updated.
     *
     * @returns {Promise<void>} A promise that resolves when the event has been emitted.
     *
     * @example
     *
     * ```ts
     * Util.Init(async () => {
     *    const testService0 = DiagRequest.from('Can.testService')
     *    testService.diagSetParameter('key', 0x01)
     *    const testService1 = DiagRequest.from('Can.testService')
     *    console.log(testService0 == testService1) // false
     *    await testService0.syncService()
     *    const testService2 = DiagRequest.from('Can.testService')
     *    console.log(testService0 == testService2) // true
     *
     * })
     * ```
     */
    changeService(): Promise<void>;
    /**
     * Subscribe to an event. When the event occurs, the listener function will be invoked.
     *
     * The valid event name should be:
     * - `'send'`: will be happen before the msg is send
     * - `'recv'`: will be happen when the response msg is recv
     *
     * @param event The event to be listened.
     * @param listener the function when event
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService')
     *     testService.On('send', ()=>{
     *         console.log('send event happened.')
     *     })
     *
     *     testService.On('recv', ()=>{
     *         console.log('recv event happened.')
     *     })
     * })
     * ```
     */
    On<T extends keyof ServiceEvent>(event: T, listener: (data: ServiceEvent[T]) => void | Promise<void>): void;
    /**
     * Subscribe to an event, only once.
     *
     * @param event - The event type.
     * @param listener - The function to subscribe.
     */
    Once<T extends keyof ServiceEvent>(event: T, listener: (data: ServiceEvent[T]) => void | Promise<void>): void;
    /**
     * Unsubscribe from an event.
     *
     * @param event - The event type.
     * @param listener - The function to unsubscribe.
     *
     * @example
     *
     * ```ts
     * Util.Init(() => {
     *     const testService = DiagRequest.from('Can.testService');
     *     testService.On('send', () => {
     *         console.log('send event happened.');
     *     });
     
     *     // The following code will not work
     *     testService.Off('send', () => {
     *         console.log('send event happened.');
     *     });
     * });
     * ```
     *
     * > **Note**: To unsubscribe from an event, you must provide a non-anonymous function.
     */
    Off<T extends keyof ServiceEvent>(event: T, listener: (data: ServiceEvent[T]) => void | Promise<void>): void;
    private asyncEmit;
    /**
     * This function will return the service name
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('ServiceName:', testService.getServiceName())
     * })
     * ```
     */
    getServiceName(): string;
    /**
     * This function will return the service describe setting in Service.
     * @returns service describe.
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('Desc:', testService.getServiceDesc())
     * })
     * ```
     */
    getServiceDesc(): string | undefined;
    /**
     * This function will return the value of the provided parameter.
     * @param paramName param name
     * @returns param value
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('SERVICE-ID Buffer:', testService.diagGetParameter('SERVICE-ID'))
     * })
     * ```
     */
    diagGetParameter(paramName: string): string | number;
    /**
     * This function will return the `Buffer` of the provided parameter.
     * @param paramName param name
     * @returns `Buffer` value of provided parameter.
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('SERVICE-ID:', testService.diagGetParameterRaw('SERVICE-ID'))
     * })
     * ```
     */
    diagGetParameterRaw(paramName: string): Buffer;
    /**
     * This function will return the bit size of the provided parameter.
     * @param paramName param name
     * @returns param bit size
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('SERVICE-ID Size:', testService.diagGetParameterSize('SERVICE-ID'))
     * })
     */
    diagGetParameterSize(paramName: string): number;
    /**
     * This function returns the names of all parameters associated with the given diag.
     *
     * @returns {string[]} An array of strings storing the names of all parameters.
     *
     * @example
     *
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService');
     *     console.log('parameter names:', testService.diagGetParameterNames())
     * })
     */
    diagGetParameterNames(): string[];
    /**
     * This function will change the parameter's bit size.
     * @param paramName parameter name
     * @param bitLen new bit size of the provided parameter.
     *
     * @example
     *
     * > It is only advisable to specify the size of num and array parameters.
     *
     * ```ts
     * Util.Init(()=>{
     *     const testService = DiagRequest.from('Can.testService')
     *
     *     // array parameter
     *     console.log('arrayParam bit size:', testService.diagGetParameterSize('arrayParam'))
     *     testService.diagSetParameterSize('arrayParam', 64)
     *     console.log('arrayParam bit size:', testService.diagGetParameterSize('arrayParam'))
     *
     *     // num parameter
     *     console.log('numParam bit size:', testService.diagGetParameterSize('numParam'))
     *     testService.diagSetParameterSize('numParam', 16)
     *     console.log('numParam bit size:', testService.diagGetParameterSize('numParam'))
     *
     *     console.log('ascii bit size:', testService.diagGetParameterSize('asciiParam'))
     *     testService.diagSetParameterSize('asciiParam', 16)
     *     console.log('ascii bit size:', testService.diagGetParameterSize('asciiParam'))
     * })
     * ```
     *
     */
    diagSetParameterSize(paramName: string, bitLen: number): void;
    /**
     * This function will change the provided parameter's value.
     * @param paramName parameter's name need to be changed.
     * @param value new value of the provided parameter.
     *
     * @example
     *
     * > Add relative param in Service.
     *
     * 1. **array parameter**
     *
     *     ```ts
     *     Util.Init(()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *
     *         console.log('arrayParam:', testService.diagGetParameter('arrayParam'))
     *         testService.diagSetParameter('arrayParam', '12 34 56 78')
     *         console.log('arrayParam:', testService.diagGetParameter('arrayParam'))
     *     })
     *     ```
     *
     * 2. **num parameter**
     *
     *     ```ts
     *     Util.Init(()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *
     *         // 8 bit number
     *         console.log('8 bits num:', testService.diagGetParameter('numParam'))
     *         testService.diagSetParameter('numParam', '12')
     *         console.log('set parameter with str:', testService.diagGetParameter('numParam'))
     *         testService.diagSetParameter('numParam', 99)
     *         console.log('set parameter with number:', testService.diagGetParameter('numParam'))
     *
     *         // 16 bit number
     *         console.log('8 bits num:', testService.diagGetParameterRaw('numParam'))
     *         testService.diagSetParameterSize('numParam', 16)
     *         console.log('change size to 16 bits:', testService.diagGetParameterRaw('numParam'))
     *         testService.diagSetParameter('numParam', '257')
     *         console.log('set parameter with str', testService.diagGetParameterRaw('numParam'))
     *         testService.diagSetParameter('numParam', 65534)
     *         console.log('set parameter with number', testService.diagGetParameterRaw('numParam'))
     *     })
     *     ```
     * 3. **ascii parameter**
     *
     *     > The ascii parameter formats the input value into a string. It is advisable to avoid using numbers as input.
     *
     *     ```ts
     *     Util.Init(()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *
     *         // 8 bit number
     *         console.log('8 bits num:', testService.diagGetParameterRaw('asciiParam'))
     *         testService.diagSetParameter('asciiParam', 'A')
     *         console.log('set parameter with str:', testService.diagGetParameterRaw('asciiParam'))
     *
     *         // 16 bit number
     *         console.log('8 bits num:', testService.diagGetParameterRaw('asciiParam'))
     *         await testService.diagSetParameterSize('asciiParam', 16)
     *         console.log('change size to 16 bits:', testService.diagGetParameterRaw('asciiParam'))
     *         await testService.diagSetParameter('asciiParam', 'AB')
     *         console.log('set parameter with str', testService.diagGetParameterRaw('asciiParam'))
     *     })
     *     ```
     * 4. **unicode parameter**
     *
     *     ```ts
     *     Util.Init(()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *
     *         // 8 bit number
     *         console.log('24 bits num:', testService.diagGetParameter('unicodeParam'))
     *         testService.diagSetParameter('unicodeParam', '❤')
     *         console.log('set parameter with str:', testService.diagGetParameter('unicodeParam'))
     *
     *         // 16 bit number
     *         console.log('48 bits num:', testService.diagGetParameter('unicodeParam'))
     *         testService.diagSetParameterSize('unicodeParam', 48)
     *         console.log('change size to 16 bits:', testService.diagGetParameter('unicodeParam'))
     *         testService.diagSetParameter('unicodeParam', '❤️')
     *         console.log('set parameter with str', testService.diagGetParameter('unicodeParam'))
     *     })
     *     ```
     *
     * 5. **float parameter**
     *
     *     ```ts
     *     Util.Init(()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *
     *         // 8 bit number
     *         console.log('32 bits num:', testService.diagGetParameter('floatParam'))
     *         testService.diagSetParameter('floatParam', 0.12345)
     *         console.log('set parameter with float:', testService.diagGetParameter('floatParam'))
     *     })
     *     ```
     */
    diagSetParameter(paramName: string, value: string | number): void;
    /**
     * This function will change the provided parameter's value with provided `Buffer` value.
     *
     * @param paramName parameter's name need to be changed.
     * @param {Buffer} value new `Buffer` value of the provided parameter.
     *
     * @example
     *
     * > Add relative param in Service.
     *
     * This function modifies the value of a parameter using a Buffer. The Buffer's value will be transferred at the TP layer.
     * You can generate a Buffer using the following methods:
     *
     * ```ts
     * const newValue1 = Buffer.from([0x12, 0x34, 0x56, 0x78]);
     *
     * const newValue2 = Buffer.alloc(4);
     * newValue2.writeUInt8(0x01, 0);
     * newValue2.writeUInt8(0x02, 1);
     * newValue2.writeUInt8(0x03, 2);
     * newValue2.writeUInt8(0x04, 3);
     *
     * const newValue3 = Buffer.from('11223344', 'hex');
     * ```
     *
     * To modify an array parameter, you can use the following example:
     *
     * ```ts
     * Util.Init(() => {
    
     *     const testService = DiagRequest.from('Can.testService');
     *
     *     console.log('arrayParam:', testService.diagGetParameter('arrayParam'));
     *     const newValue1 = Buffer.from([0x12, 0x34, 0x56, 0x78]);
     *
     *     testService.diagSetParameterRaw('arrayParam', newValue1);
     *     console.log('arrayParam:', testService.diagGetParameter('arrayParam'));
     * });
     * ```
     *
     * > For more examples on changing different parameter types, please refer to the {@link diagSetParameter | `diagSetParameter`} function.
     *
     */
    diagSetParameterRaw(paramName: string, value: Buffer): void;
    /**
     * Sends a diagnostic output command to the specified device.
     *
     * @param deviceName - The name of the device to send the diagnostic command to.
     * @param addressName - The address name associated with the device.
     * @returns The diagnostic output timestamp.
     */
    outputDiag(deviceName?: string, addressName?: string): Promise<number>;
    /**
     * This function modifies all values of a service.
     *
     * @param data - The new data's buffer value.
     *
     * @example
     *
     * This function is typically used by a job to modify all data of a service. The following code demonstrates how to generate a new service and set its raw data:
     *
     * ```ts
     * Util.Register('Can.testJob', async (v) => {
     *     //create a new DiagRequest in Can tester
     *     const testService = new DiagRequest('Can');
     *     const newData = Buffer.from([0x10, 0x01, 0x00, 0x01, 0x02]);
     *     await testService.diagSetRaw(newData);
     *     return [testService];
     * });
     * ```
     *
     * > - Ensure that the job `Can.testJob` is already configured in Service.
     * > - The return type of a job should be a array.
     *
     * You can also modify the raw data of an existing service with the following code:
     *
     * ```ts
     * Util.Init(() => {
    
     *     const testService = DiagRequest.from('Can.testService');
     *     const newData = Buffer.from([0x10, 0x02]);
     *     await testService.diagSetRaw(newData);
     * });
     * ```
     *
     *
     * > - Ensure that the service `Can.testService` is already configured in Service.
     * > - The new raw data size should be equal to the old raw data size.
     */
    diagSetRaw(data: Buffer): void;
    /**
     * This function will return a raw data of one service.
     * @returns raw data of one service.
     *
     * @example
     *
     * ```ts
     * Util.Init(()=>{
    
     *     const testService = DiagRequest.from('Can.testService')
     *     console.log('get raw data:', testService.diagGetRaw())
     * })
     * ```
     */
    diagGetRaw(): Buffer<ArrayBuffer>;
}
/**
 * @category UDS
 */
declare class DiagJob extends Service {
    constructor(testerName: string, service: ServiceItem);
    from(jobName: keyof Jobs): DiagJob;
}
/**
 * @category UDS
 */
declare class DiagResponse extends Service {
    private addr?;
    constructor(testerName: string, service: ServiceItem, addr?: UdsAddress);
    /**
     * Get the UDS address of the response. The address may be undefined if not set.
     * @returns {UdsAddress | undefined} The UDS address if set, undefined otherwise
     */
    getUdsAddress(): UdsAddress | undefined;
    /**
     * @param {string} serviceName
     *
     * > serviceName's type '{{{serviceName}}}' is the string configured by Service.
     *
     * @example
     *
     *     ```ts
     *     Util.Init(async ()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *         testService.On('send', ()=>{
     *             console.log('send event happened.')
     *         })
     *     }
     *     ```
     */
    static from(serviceName: ServiceName): DiagResponse;
    /**
     * @param {DiagRequest} req
     * @returns {DiagResponse}
     *
     * > req's type '{{{DiagRequest}}}' is the DiagRequest object.
     *
     * @example
     *
     * ```ts
     * Util.On('Can.testService.send', (v)=>{
     *     const response = DiagResponse.fromDiagRequest(v)
     * })
     * ```
     */
    static fromDiagRequest(req: DiagRequest): DiagResponse;
    /**
     * This function will return whether the response is a positive response or not.
     * @returns bool
     *
     * @example
     *
     * ```ts
     * Util.On('Can.testService.recv', (v)=>{
     *     console.log('response is positive:', v.diagIsPositiveResponse())
     * })
     * ```
     *
     */
    diagIsPositiveResponse(): boolean;
    /**
     * This function will return the response code of one response.
     *
     * > **NOTE**: Positive response does not have response code.
     *
     * @returns response code.
     *
     * @example
     *
     * // here testService2 is a RequestDownload(0x34) service
     * Util.On('Can.testService2.recv', (v)=>{
     *     console.log('response code', v.diagGetResponseCode())
     * })
     *
     */
    diagGetResponseCode(): number | undefined;
}
/**
 * @category UDS
 */
declare class DiagRequest extends Service {
    private addr?;
    constructor(testerName: string, service: ServiceItem, addr?: UdsAddress);
    /**
     * Get the UDS address of the request.
     * @returns {UdsAddress | undefined} The UDS address if set, undefined otherwise
     */
    getUdsAddress(): UdsAddress | undefined;
    /**
     * @param {string} serviceName
     *
     * > serviceName's type '{{{serviceName}}}' is the string configured by Service.
     *
     * @example
     *
     *     ```ts
     *     Util.Init(async ()=>{
     *         // add param arrayParam in Service.
     *         const testService = DiagRequest.from('Can.testService')
     *         testService.On('send', ()=>{
     *             console.log('send event happened.')
     *         })
     *     }
     *     ```
     */
    static from(serviceName: ServiceName): DiagRequest;
}
/**
 * @category Util
 */
declare class UtilClass {
    private isMain;
    private event;
    private funcMap;
    private testerName?;
    /**
     * Register a handler function for a job.
     * @param jobs
     * Job name, valid format is \<tester name\>.\<job name\>
     * @param func
     * Handler function for the job
     *
     * @example
     *
     * ```ts
     * Util.Register('Can.testJob', async (v) => {
    
     *     const testService = new DiagRequest();
     *     const newData = Buffer.from([0x10, 0x01, 0x00, 0x01, 0x02]);
     *     await testService.diagSetRaw(newData);
     *     return [testService];
     * });
     * ```
     */
    Register(jobs: JobName, func: Jobs[keyof Jobs]): void;
    private workerOn;
    /**
     * Registers an event listener for CAN messages.
     *
     * @param id - The CAN message ID or ${databaseName}.${frameName} to listen for. If `true`, listens for all CAN messages.
     * @param fc - The callback function to be invoked when a CAN message is received.
     */
    OnCan(id: number | string | true, fc: (msg: CanMessage) => void | Promise<void>): void;
    /**
     * Registers an event listener for signal updates from CAN/LIN databases.
     * The signal will be emitted whenever the specified signal value changes.
     *
     * @param signal - The signal name to listen for (format: "database.signalName")
     * @param fc - The callback function invoked when the signal is updated
     * @param fc.rawValue - The raw signal value (number or Buffer)
     * @param fc.physValue - The physical/scaled signal value (could be enum string or scaled number)
     *
     * @example
     * ```typescript
     * // Listen for engine RPM signal updates
     * OnSignal("Engine.EngineRPM", ({ rawValue, physValue }) => {
     *   console.log(`Engine RPM: ${physValue} (raw: ${rawValue})`)
     * })
     *
     * // Listen for gear position signal with enum values
     * OnSignal("Transmission.GearPosition", ({ rawValue, physValue }) => {
     *   console.log(`Gear: ${physValue}`) // Could be "Park", "Drive", "Reverse", etc.
     * })
     *
     * // Async callback example
     * OnSignal("Battery.Voltage", async ({ rawValue, physValue }) => {
     *   if (physValue < 12.0) {
     *     await sendWarning("Low battery voltage detected!")
     *   }
     * })
     * ```
     */
    OnSignal(signal: SignalName, fc: ({ rawValue, physValue }: {
        rawValue: number | Buffer;
        physValue: any;
    }) => void | Promise<void>): void;
    /**
     * Registers a one-time event listener for signal updates from CAN/LIN databases.
     * The listener will be automatically removed after the first signal update.
     *
     * @param signal - The signal name to listen for (format: "database.signalName")
     * @param fc - The callback function invoked when the signal is updated (only once)
     * @param fc.rawValue - The raw signal value (number or Buffer)
     * @param fc.physValue - The physical/scaled signal value (could be enum string or scaled number)
     *
     * @example
     * ```typescript
     * // Wait for the first engine start signal
     * OnSignalOnce("Engine.EngineStatus", ({ rawValue, physValue }) => {
     *   if (physValue === "Running") {
     *     console.log("Engine started successfully!")
     *   }
     * })
     *
     * // Wait for initialization complete signal
     * OnSignalOnce("System.InitStatus", async ({ rawValue, physValue }) => {
     *   if (physValue === "Complete") {
     *     await startDiagnosticSequence()
     *   }
     * })
     * ```
     */
    OnSignalOnce(signal: SignalName, fc: ({ rawValue, physValue }: {
        rawValue: number | Buffer;
        physValue: any;
    }) => void | Promise<void>): void;
    /**
     * Removes an event listener for signal updates from CAN/LIN databases.
     * The specified callback function will no longer be invoked for signal updates.
     *
     * @param signal - The signal name to stop listening for (format: "database.signalName")
     * @param fc - The exact callback function to remove (must be the same reference)
     *
     * @example
     * ```typescript
     * // Define a callback function
     * const rpmCallback = ({ rawValue, physValue }) => {
     *   console.log(`RPM: ${physValue}`)
     * }
     *
     * // Register the listener
     * OnSignal("Engine.EngineRPM", rpmCallback)
     *
     * // Later, remove the listener
     * OffSignal("Engine.EngineRPM", rpmCallback)
     *
     * // Anonymous functions cannot be removed easily, so use named functions:
     * // ❌ This won't work for removal:
     * // OnSignal("Engine.RPM", ({ physValue }) => console.log(physValue))
     *
     * // ✅ This will work for removal:
     * const callback = ({ physValue }) => console.log(physValue)
     * OnSignal("Engine.RPM", callback)
     * OffSignal("Engine.RPM", callback)
     * ```
     */
    OffSignal(signal: SignalName, fc: ({ rawValue, physValue }: {
        rawValue: number | Buffer;
        physValue: any;
    }) => void | Promise<void>): void;
    /**
     * Get the tester name, valid in Tester script
     * @returns {string}
     */
    getTesterName(): string | undefined;
    /**
     * Registers an event listener for CAN messages that will be invoked once.
     *
     * @param id - The CAN message ID or ${databaseName}.${frameName} to listen for. If `true`, listens for all CAN messages.
     * @param fc - The callback function to be invoked when a CAN message is received.
     */
    OnCanOnce(id: number | true, fc: (msg: CanMessage) => void | Promise<void>): void;
    /**
     * Unsubscribes from CAN messages.
     *
     * @param id - The identifier of the CAN message to unsubscribe from. If `true`, unsubscribes from all CAN messages.
     * @param fc - The callback function to remove from the event listeners.
     */
    OffCan(id: number | true, fc: (msg: CanMessage) => void | Promise<void>): void;
    /**
     * Registers an event listener for LIN messages that will be invoked once.
     *
     * @param id - The LIN message ID or ${databaseName}.${frameName} to listen for. If `true`, listens for all LIN messages.
     * @param fc - The callback function to be invoked when a LIN message is received.
     */
    OnLinOnce(id: number | string | true, fc: (msg: LinMsg) => void | Promise<void>): void;
    /**
     * Registers an event listener for LIN messages.
     *
     * @param id - The LIN message ID or ${databaseName}.${frameName} to listen for. If `true`, listens for all LIN messages.
     * @param fc - The callback function to be invoked when a LIN message is received.
     */
    OnLin(id: number | string | true, fc: (msg: LinMsg) => void | Promise<void>): void;
    /**
     * Unsubscribes from LIN messages.
     *
     * @param id - The identifier of the LIN message to unsubscribe from. If `true`, unsubscribes from all LIN messages.
     * @param fc - The callback function to remove from the event listeners.
     */
    OffLin(id: number | string | true, fc: (msg: LinMsg) => void | Promise<void>): void;
    /**
     * Registers an event listener for SOMEIP messages.
     *
     * @param id - The SOMEIP message identifier in format "service.instance.method" or "service.instance.*". If `true`, listens for all SOMEIP messages.
     * @param fc - The callback function to be invoked when a SOMEIP message is received.
     *
     * @example
     * ```ts
     * // Listen for all SOMEIP messages
     * Util.OnSomeipMessage(true, (msg) => {
     *   console.log('Received SOMEIP message:', msg);
     * });
     *
     * // Listen for specific service/instance/method
     * Util.OnSomeipMessage('0034.5678.90ab', (msg) => {
     *   console.log('Received specific SOMEIP message:', msg);
     * });
     *
     * // Listen for specific service/wildcard
     * Util.OnSomeipMessage('0034.*.*', (msg) => {
     *   console.log('Received specific SOMEIP message:', msg);
     * });
     * ```
     */
    OnSomeipMessage(id: string | true, fc: (msg: SomeipMessageRequest | SomeipMessageResponse) => void | Promise<void>): void;
    /**
     * Unsubscribes from SOMEIP messages.
     *
     * @param id - The SOMEIP message identifier to unsubscribe from. If `true`, unsubscribes from all SOMEIP messages.
     * @param fc - The callback function to remove from the event listeners.
     *
     * @example
     * ```ts
     * const handler = (msg) => console.log(msg);
     *
     * // Unsubscribe from all SOMEIP messages
     * Util.OffSomeipMessage(true, handler);
     *
     * // Unsubscribe from specific service/instance/method
     * Util.OffSomeipMessage('1234.5678.90ab', handler);
     * ```
     */
    OffSomeipMessage(id: string | true, fc: (msg: SomeipMessageRequest | SomeipMessageResponse) => void | Promise<void>): void;
    /**
     * Registers a one-time event listener for SOMEIP messages.
     * The listener will be automatically removed after being invoked once.
     *
     * @param id - The SOMEIP message identifier in format "service.instance.method" or "service.instance.*". If `true`, listens for all SOMEIP messages.
     * @param fc - The callback function to be invoked once when a SOMEIP message is received.
     *
     * @example
     * ```ts
     * // Listen once for any SOMEIP message
     * Util.OnSomeipMessageOnce(true, (msg) => {
     *   console.log('Received one SOMEIP message:', msg);
     * });
     *
     * // Listen once for specific service/instance/method
     * Util.OnSomeipMessageOnce('1234.5678.90ab', (msg) => {
     *   console.log('Received one specific SOMEIP message:', msg);
     * });
     * ```
     */
    OnSomeipMessageOnce(id: string | true, fc: (msg: SomeipMessageRequest | SomeipMessageResponse) => void | Promise<void>): void;
    /**
     * Registers an event listener for a specific key.
     *
     * @param key - The key to listen for. Only the first character of the key is used, * is a wildcard.
     * @param fc - The callback function to be executed when the event is triggered.
     *             This can be a synchronous function or a function returning a Promise.
     */
    OnKey(key: string, fc: (key: string) => void | Promise<void>): void;
    /**
     * Registers an event listener for a specific key that will be invoked once.
     *
     * @param key - The key to listen for. Only the first character of the key is used, * is a wildcard.
     * @param fc - The callback function to be executed when the event is triggered.
     *             This can be a synchronous function or a function returning a Promise.
     */
    OnKeyOnce(key: string, fc: (key: string) => void | Promise<void>): void;
    /**
     * Unsubscribes from an event listener for a specific key.
     *
     * @param key - The key to unsubscribe from. Only the first character of the key is used, * is a wildcard.
     * @param fc - The callback function to remove from the event listeners.
     */
    OffKey(key: string, fc: (key: string) => void | Promise<void>): void;
    /**
     * Registers an event listener for a variable update.
     *
     * @param name - The name of the variable to listen for, * is a wildcard.
     * @param fc - The callback function to be executed when the variable is updated.
     *             This can be a synchronous function or a function returning a Promise.
     *             The callback receives an object with name and value properties.
     *
     * @example
     * ```ts
     * // Listen for updates to a specific variable
     * Util.OnVar('temperature', ({name, value}) => {
     *   console.log(`${name} changed to ${value}`);
     * });
     *
     * // Listen for all variable updates using wildcard
     * Util.OnVar('*', ({name, value}) => {
     *   console.log(`Variable ${name} updated to ${value}`);
     * });
     * ```
     */
    OnVar<Name extends keyof VariableMap>(name: Name, fc: ({ name, value }: {
        name: Name;
        value: VariableMap[Name];
    }) => void | Promise<void>): void;
    /**
     * Registers an event listener for a variable update that will be invoked once.
     *
     * @param name - The name of the variable to listen for, * is a wildcard.
     * @param fc - The callback function to be executed when the variable is updated.
     *             This can be a synchronous function or a function returning a Promise.
     *             The callback receives an object with name and value properties.
     */
    OnVarOnce<Name extends keyof VariableMap>(name: Name, fc: ({ name, value }: {
        name: Name;
        value: VariableMap[Name];
    }) => void | Promise<void>): void;
    /**
     * Unsubscribes from an event listener for a variable update.
     *
     * @param name - The name of the variable to unsubscribe from, * is a wildcard.
     * @param fc - The callback function to remove from the event listeners.
     */
    OffVar<Name extends keyof VariableMap>(name: Name, fc: ({ name, value }: {
        name: Name;
        value: VariableMap[Name];
    }) => void | Promise<void>): void;
    /**
     * Subscribe to an event once, invoking the registered function when the event is emitted.
     * @param eventName
     * Service name, formatted as \<tester name\>.\<service name\>.\<send|recv\>
     *
     * @param listener
     * Function to be called when the event is emitted
     *
     * @example
     *
     * ```ts
     * Util.OnOnce('Can.testService.send', async (req) => {
     *    // The req is a `DiagRequest`
     *    console.log(req.getServiceName(), ': send once');
     * });
     * ```
     */
    OnOnce<Name extends keyof EventMap>(eventName: Name, listener: (eventData: EventMap[Name]) => void | Promise<void>): void;
    /**
     * Subscribe to an event, invoking the registered function when the event is emitted.
     * @param eventName
     * Service name, formatted as \<tester name\>.\<service name\>.\<send|recv\>
     *
     * @param listener
     * Function to be called when the event is emitted
     *
     * @example
     *
     * > The `UDS` is a UDSClass type and has already been created by Service.
     *
     * 1. *send functions*
     *
     *     ```ts
     *     Util.On('Can.testService.send', async (req) => {
     *        // The req is a `DiagRequest`
     *        console.log(req.getServiceName(), ': send');
     *     });
     *     ```
     * 2. *recv function*
     *
     *     ```ts
     *     Util.On('Can.testService.recv', async (req) => {
     *        // The req is a `DiagResponse`
     *        console.log(req.getServiceName(), ':recv');
     *     });
     *     ```
     *
     */
    On<Name extends keyof EventMap>(eventName: Name, listener: (eventData: EventMap[Name]) => void | Promise<void>): void;
    /**
     * Unsubscribe from an event.
     *
     * > Only non-anonymous functions can be unsubscribed.
     *
     * @param eventName
     * Service name, formatted as \<tester name\>.\<service name\>.\<send|recv\>
     *
     * @param listener
     * Function to be unsubscribed
     *
     * @example
     *
     * ```ts
     * Util.On('Can.testService.send', ()=>{
     *     console.log('this function will not be Off')
     * })
     *
     * Util.Off('Can.testService.send', ()=>{
     *     console.log('this function will not be Off')
     * })
     *
     * ```
     *
     */
    Off<Name extends keyof EventMap>(eventName: Name, listener: (eventData: EventMap[Name]) => void | Promise<void>): void;
    private start;
    private canMsg;
    private linMsg;
    private someipMsg;
    private keyDown;
    private varUpdate;
    private evnetDone;
    constructor();
    /**
     * Register a function, this function will be invoked when UDSClass is initialized.
     * @param fc Non-async or async function
     *
     * @example
     *
     * - Perform actions following UDS initialization using a normal function.
     *     ```ts
     *     Util.Init(()=>{
     *       console.log('Hello UDS!')
     *     })
     *     ```
     *
     * - Perform actions following UDS initialization using an async function.
     *     ```ts
     *     Util.Init(async ()=>{
     *       const file=await fs.readFile(path.join(process.env.PROJECT_ROOT,'file.bin'))
     *       let length=file.length
     *       console.log('Hello UDS file! file length is', length)
     *     })
     *     ```
     *
     * - The last registered function will override the previous ones.
     *     ```ts
     *     // The following code will be ignored
     *     Util.Init(async ()=>{
     *         console.log('1')
     *     })
     *
     *     // The following code will take effect
     *     Util.Init(async ()=>{
     *         console.log('2')
     *     })
     *     ```
     */
    Init(fc: () => void | Promise<void>): void;
    /**
     * Register a function, this function will be invoked when UDSClass is terminated.
     * @param fc Non-async or async function
     *
     * @example
     *
     *
     */
    End(fc: () => void | Promise<void>): void;
}
/**
 * Global instance of UDSClass, providing access to UDS functionality throughout the application.
 * Use this instance to interact with UDS features and services.
 *
 * @category Util
 * @type {UDSClass}
 *
 * @example
 * 1. *Init function*
 *     - Perform actions following UDS initialization using a normal function.
 *         ```ts
 *         Util.Init(()=>{
 *           console.log('Hello UDS!')
 *         })
 *         ```
 *
 *     - Perform actions following UDS initialization using an async function.
 *         ```ts
 *         Util.Init(async ()=>{
 *           const file=await fs.readFile(path.join(process.env.PROJECT_ROOT,'file.bin'))
 *           let length=file.length
 *           console.log('Hello UDS file! file length is', length)
 *         })
 *         ```
 *
 * 2. *send functions*
 *     > * This function will be called after the message has been sent.
 *     > * Please replace `Can.DiagRequest.send` with your own service item name. The format is `<tester name>.<service item name>.send`
 *
 *     ```ts
 *     Util.On('Can.DiagRequest.send', async (req) => {
 *        // The req is a `DiagRequest`
 *        console.log(req.getServiceName(), ': send');
 *     });
 *     ```
 *
 * 3. *recv function*
 *     > * This function will be called after the response message has been received.
 *     > * Please replace `Can.DiagRequest.recv` with your own service item name. The format is `<tester name>.<service item name>.recv`
 *
 *     ```ts
 *     Util.On('Can.DiagRequest.recv', async (req) => {
 *        // The req is a `DiagResponse`
 *        console.log(req.getServiceName(), ':recv');
 *     });
 *     ```
 *
 * 4. **More**
 *     > For more details, please refer to the {@link UtilClass | `UtilClass`} class.
 */
declare const Util: UtilClass;
/**
 * Sets a "pending transmit" handler for CAN messages used by jobs/diagnostics.
 *
 * Allows test frameworks or diagnostic jobs to temporarily override outgoing CAN message transmission.
 * The provided callback is invoked before each CAN transmit.
 *
 * @param func - Callback taking a CanMessage and returning:
 *   - a Buffer (to override and send as transmit data),
 *   - msg.data (to send the message unchanged),
 *   - undefined (to suppress/disable this transmission),
 *   - or a Promise resolving to any of the above.
 *
 * @returns {void}
 *
 * @category E2E
 *
 * @example
 * setTxPending(async (msg) => {
 *   // E2E test: intercept message with ID 0x200
 *   if (msg.id === 0x200) {
 *     // Replace transmit data for E2E injection
 *     return Buffer.from([0xE2, 0xE2, 0xCA, 0xT1]);
 *   }
 *   // Block this transmission (do not send)
 *   return undefined;
 * });
 *
 * @example
 * setTxPending((msg) => {
 *   // Only log, transmit as usual
 *   console.log("CAN TX:", msg);
 *   return msg.data; // will not alter data
 * });
 */
declare function setTxPending(func: (msg: CanMessage) => Promise<Buffer | undefined> | Buffer | undefined): void;
/**
 * Sends a CAN message
 *
 * @category CAN
 * @param {CanMessage} msg - The CAN message to be sent
 * @returns {Promise<number>} - Returns a promise that resolves to sent timestamp
 * @example
 * ```ts
 * // Send a standard CAN message with 8 bytes of data
 *  const canMsg: CanMessage = {
      id: 0x111, // CAN ID in hex
      data: Buffer.from([0,1,2,3,4,5,6,7]), // 8 bytes of data
      dir: 'OUT', // Output direction
      msgType: {
        idType: CAN_ID_TYPE.STANDARD, // Standard CAN frame
        remote: false, // Not a remote frame
        brs: false, // No bit rate switching
        canfd: false // Not a CAN FD frame
      }
    }
   const timestamp = await output(canMsg) // Send and get timestamp
 * ```
 */
declare function output(msg: CanMessage): Promise<number>;
/**
 * Sends a LIN message
 *
 * @category LIN
 * @param {LinMsg} msg - The LIN message to be sent
 * @returns {Promise<number>} - Returns a promise that resolves to sent timestamp
 */
declare function output(msg: LinMsg): Promise<number>;
/**
 * Sends a SOMEIP message
 *
 * @category SOMEIP
 * @param {SomeipMessage} msg - The SOMEIP message to be sent
 * @returns {Promise<number>} - Returns a promise that resolves to sent timestamp
 */
declare function output(msg: SomeipMessageBase): Promise<number>;

/**
 * Set a signal value
 *
 * @category LIN
 * @category CAN
 * @param {SignalName} signal - The signal to set, dbName.SignalName
 * @param {number|number[]} value - The value to set, can be single number or array
 * @returns {Promise<void>} - Returns a promise that resolves when value is set
 *
 * @example
 * ```ts
 * // Set single value signal
 * await setSignal(lin.xxxx', 123);
 *
 * // Set array value signal
 * await setSignal('lin.xxxx', [1, 2, 3, 4]);
 * ```
 */
declare function setSignal(signal: SignalName, value: number | number[] | string): Promise<void>;
/**
 * Get a signal's raw value and physical value
 *
 * @category LIN
 * @category CAN
 * @param {SignalName} signal - The signal name in format 'dbName.signalName'
 * @returns {Object} Object containing raw value and physical value
 * @returns {number|number[]|undefined} rawValue - The raw value of the signal
 * @returns {any} physValue - The physical value or enum value of the signal
 *
 * @example
 * ```ts
 * // Get signal value for CAN signal
 * const canSignal = getSignal('can.engineSpeed');
 * console.log('Raw value:', canSignal.rawValue); // e.g. 1000
 * console.log('Physical value:', canSignal.physValue); // e.g. '1000 rpm'
 *
 * // Get signal value for LIN signal
 * const linSignal = getSignal('lin.temperature');
 * console.log('Raw value:', linSignal.rawValue); // e.g. 50
 * console.log('Physical value:', linSignal.physValue); // e.g. '25°C'
 * ```
 */
declare function getSignal(signal: SignalName): {
    rawValue: number | number[] | undefined;
    physValue: any;
};
/**
 * Set a variable value
 *
 * @category Variable
 * @param {keyof VariableMap} name - The variable name
 * @param {number|number[]|string} value - The value to set, can be single number or array
 * @returns {void} - Returns nothing
 *
 * @example
 * ```ts
 * // Set single value signal
 * setVar('var2', 123);
 *
 * // Set array value signal
 * setVar('namespace.var1', [1, 2, 3, 4]);
 * ```
 */
declare function setVar<T extends keyof VariableMap>(name: T, value: VariableMap[T]): void;
/**
 * Set multiple variable values at once
 *
 * @category Variable
 * @param {Partial<VariableMap>} vars - An object where keys are variable names and values are the values to set
 * @returns {void} - Returns nothing
 *
 * @example
 * ```ts
 * // Set multiple variables at once
 * setVars({
 *   'var1': 123,
 *   'var2': 'hello',
 *   'namespace.var3': [1, 2, 3, 4]
 * });
 * ```
 */
declare function setVars(vars: Partial<VariableMap>): void;
/**
 * Get a variable value
 *
 * @category Variable
 * @param {string} varName - The name of the variable to get
 * @returns {VarItem} - Returns the variable value and metadata
 *
 * @example
 * ```ts
 * // Get a variable value
 * const var1 = getVar('namespace.var1');
 * console.log(var1.value); // Access the value
 * console.log(var1.type); // Access the type
 * ```
 */
declare function getVar<T extends keyof VariableMap>(varName: T): VariableMap[T];
/**
 * Run a UDS sequence
 *
 * @category UDS
 * @param {UdsSeqName} seqName - The name of the UDS sequence to run
 * @param {string} [device] - The optional device name to run the sequence on when multiple devices are connected
 * @returns {Promise<void>} - Returns a promise that resolves when sequence completes
 *
 * @example
 * ```ts
 * // Run a UDS sequence
 * await runUdsSeq('MySequence');
 *
 * // Run sequence on specific device
 * await runUdsSeq('MySequence', 'Device1');
 * ```
 */
declare function runUdsSeq(seqName: UdsSeqName, device?: string): Promise<void>;
/**
 * Stop a running UDS sequence
 *
 * @category UDS
 * @param {UdsSeqName} seqName - The name of the UDS sequence to stop
 * @param {string} [device] - The optional device name when multiple devices are connected
 * @returns {Promise<void>} - Returns a promise that resolves when sequence is stopped
 *
 * @example
 * ```ts
 * // Stop a UDS sequence
 * await stopUdsSeq('MySequence');
 * ```
 */
declare function stopUdsSeq(seqName: UdsSeqName, device?: string): Promise<void>;
/**
 * Register a virtual entity
 *
 * @deprecated This API is deprecated and not working, enable it through the simulate_by field in the tester config
 *
 * @category DOIP
 * @param {EntityAddr} entity - The entity to be registered.
 * @param {string} ip - The IP address of the entity, if node connected to multiple devices.
 * @returns {Promise<void>} - Returns a promise that resolves when the entity is registered.
 */
declare function RegisterEthVirtualEntity(entity: VinInfo, ip?: string): Promise<void>;
type TestEventGenerator = Parameters<typeof dot>[0];
declare function reporter(source: TestEventGenerator): AsyncGenerator<never, void, unknown>;
/**
 * Start a LIN scheduler
 *
 * @category LIN
 * @param {string} schName - The name of the scheduler to start
 * @returns {Promise<void>} - Returns a promise that resolves when scheduler is started
 *
 * @example
 * ```ts
 * // Start scheduler with default settings
 * await linStartScheduler('MyScheduler');
 * ```
 */
declare function linStartScheduler(schName: string): Promise<void>;
/**
 * Start a LIN scheduler
 *
 * @category LIN
 * @param {string} schName - The name of the scheduler to start
 * @param {number} slot - The slot number for the scheduler
 * @returns {Promise<void>} - Returns a promise that resolves when scheduler is started
 *
 * @example
 * ```ts
 * // Start scheduler with specific slot
 * await linStartScheduler('MyScheduler', 0);
 * ```
 */
declare function linStartScheduler(schName: string, slot: number): Promise<void>;
/**
 * Start a LIN scheduler
 *
 * @category LIN
 * @param {string} schName - The name of the scheduler to start
 * @param {number} slot - The slot number for the scheduler
 * @param {string} device - The device name to start the scheduler on
 * @returns {Promise<void>} - Returns a promise that resolves when scheduler is started
 *
 * @example
 * ```ts
 * // Start scheduler with slot and device
 * await linStartScheduler('MyScheduler', 0, 'LinDevice1');
 * ```
 */
declare function linStartScheduler(schName: string, slot: number, device: string): Promise<void>;
/**
 * Control the power of a LIN device
 *
 * @category LIN
 * @param {boolean} power - The power state to set
 * @param {string} [device] - The optional device name when multiple devices are connected
 * @returns {Promise<void>} - Returns a promise that resolves when power is set
 *
 * @note This function is only available on LinCable devices (https://app.whyengineer.com/docs/um/hardware/lincable.html)
 *
 * @example
 * ```ts
 * // Set power to true
 * await linPowerCtrl(true);
 *
 * // Set power to false on specific device
 * await linPowerCtrl(false, 'Device1');
 * ```
 */
declare function linPowerCtrl(power: boolean, device?: string): Promise<void>;
/**
 * Stop a LIN scheduler
 *
 * @category LIN
 * @param {string} [device] - The optional device name when multiple devices are connected
 * @returns {Promise<void>} - Returns a promise that resolves when scheduler is stopped
 *
 * @example
 * ```ts
 * // Stop LIN scheduler
 * await linStopScheduler();
 *
 * // Stop scheduler on specific device
 * await linStopScheduler('Device1');
 * ```
 */
declare function linStopScheduler(device?: string): Promise<void>;
/**
 * Set PWM duty cycle
 *
 * @category PWM
 * @param {Object} value - The PWM configuration object
 * @param {number} value.duty - Duty cycle percentage (0-100)
 * @param {string} [value.device] - The optional device name when multiple devices are connected
 * @returns {Promise<void>} - Returns a promise that resolves when duty cycle is set
 *
 * @example
 * ```ts
 * // Set duty cycle to 50%
 * await setPwmDuty({duty: 50});
 *
 * // Set duty cycle on specific device
 * await setPwmDuty({duty: 75, device: 'Device1'});
 * ```
 */
declare function setPwmDuty(value: {
    duty: number;
    device?: string;
}): Promise<void>;
/**
 * Get a frame from database by name
 *
 * @category LIN
 * @param {('lin')} dbType - The type of database
 * @param {string} dbName - The name of the database
 * @param {string} frameName - The name of the frame to retrieve
 *
 * @returns {LinMsg} The frame object from the database
 *
 * @example
 * ```ts
 * // Get a LIN frame
 * const linFrame = getFrameFromDB('lin', 'myLinDb', 'Frame1');

 */
declare function getFrameFromDB(dbType: 'lin', dbName: string, frameName: string): LinMsg;
/**
 * Get a frame from database by name
 *
 * @category CAN
 * @param {('can')} dbType - The type of database
 * @param {string} dbName - The name of the database
 * @param {string} frameName - The name of the frame to retrieve
 * @returns {CanMessage} The frame object from the database
 *
 * @example
 * ```ts
 * // Get a CAN frame
 * const canFrame = getFrameFromDB('can', 'myCanDb', 'Frame2');
 * ```
 */
declare function getFrameFromDB(dbType: 'can', dbName: string, frameName: string): CanMessage;

export { CAN_ADDR_FORMAT, CAN_ADDR_TYPE, CAN_ID_TYPE, DiagJob, DiagRequest, DiagResponse, LinChecksumType, LinDirection, LinMode, RegisterEthVirtualEntity, SomeipMessageRequest, SomeipMessageResponse, Util, UtilClass, after, afterEach, before, beforeEach, describe, getFrameFromDB, getCheckSum as getLinCheckSum, getSignal, getVar, linPowerCtrl, linStartScheduler, linStopScheduler, output, registerWorker, reporter, runUdsSeq, setPwmDuty, setSignal, setTxPending, setVar, setVars, stopUdsSeq, test, workerEmit };
export type { CanAddr, CanMessage, CanMsgType, EntityAddr, EthAddr, JobName, LinAddr, LinCableErrorInject, LinMsg, ServiceEvent, ServiceId, ServiceItem, ServiceName, ServiceNameRecv, ServiceNameSend, SignalName, TesterInfo, TesterName, UdsAddress, UdsSeqName, VariableMap };
